<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        pre {
            background-color: #1e1e1e;
            color: #dcdcdc;
            padding: 9px;
            border-radius: 8px;
            overflow-x:auto;
            
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
        code {
            font-family: Consolas, "Courier New", monospace;
        }
    </style>


<div class="container-fluid py-2 mt-3">

    <!-- Nav pills -->
    <ul class="nav nav-pills" role="tablist">
      <li class="nav-item">
        <a class="nav-link active" data-bs-toggle="pill" href="#menu">JS Codes</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" data-bs-toggle="pill" href="#menu1">JS Questions</a>
      </li>
      
 
     
    </ul>
  
    <!-- Tab panes -->
    <div class="tab-content">
        <div id="menu" class="container-fluid px-0 tab-pane active">

            <!-- <h3 class="mt-5">JS Codes</h3>
            <pre><code>
const sum = (a, b) => a + b;
console.log(sum(5, 3)); // Output: 8
                </code></pre>
 -->
<pre>
  <code>
for (var i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1000);
} 
//output 
3
3
3

//explanation
=> The variable i is declared with var, which is function-scoped, not block-scoped.
=> By the time the setTimeout callback is executed (after 1000ms), the for loop has already finished, and i is 3.
=> All three callbacks share the same reference to i, so they all print 3.

// How to fix for output 0,1,2
for (let i = 0; i < 3; i++) {
    setTimeout(() => console.log(i), 1000);
}
//output > 0,1,2
=> This works because let is block-scoped, and a new binding of i is created in each iteration of the loop.

//Another way
for (var i=0; i< 3; i++){
    console.log(i);
}

//OR

for (let i=0; i< 3; i++){
    console.log(i);
}

//output > 0,1,2</3>
</code>
</pre>

<pre>
<code>
function myCounter(){
  let count = 0;
  return function (){
      count++;
      console.log(count);
}
const counter1 = myCounter();
const counter2 = myCounter();
counter1();
counter1();
counter2();

// Output > 1 2 1
  </code>
</pre>
<pre>
  <code>
function myCounter(){
  let count = 0;
  return function (){
      count++;
      console.log(count);
  }
}
const counter = myCounter();

counter();
counter();
counter();

//ouput > 1,2,3
  </code>
</pre>
<pre>
  <code>
function myCounter(){
    let count = 10;
    return function (){
    console.log(count);
    }
}
const counter = myCounter();

counter();
counter();
counter();

//output > 10,10,10
  </code>
</pre>

<pre>
<code>
    function myCounter(){
    let count = 10;
    return function (){
        let count = 20;
        console.log(count);
    }
}
const counter = myCounter();

counter();
counter();
counter();

//output > 20,20,20
</code>
</pre>
<pre>
    <code>
const nums1 = [1,2,3,4,5];
const nums2  = [1,2,3,6,7,8,9];

const sortNum = function myFun(arr1, arr2) {
   return arr1.filter((value)=>arr2.includes(value));
console.log(sortNum(nums1,nums2)) ;
//[ 1, 2, 3 ] output
    </code>
</pre>
<pre>
    <code>

// reverse arry number

const nums = [1,2,3,4,5,6,7];

const reverseNum = function myFun(arr){
    let reverse = []
    for(let i=arr.length-1; i>=0; i--){
        reverse.push(arr[i])
    }
    return reverse;
}
console.log(reverseNum(nums))
    </code>
</pre>
<pre>
    <code>
// Implement a function to reverse a string without using the built-in reverse() method.     
const nums = 'Vivek';

const reverseNum = function myFun(arr){
    let reverse = ''
    for(let i=arr.length-1; i>=0; i--){
        reverse = reverse+arr[i]
    }
    return reverse;
}
console.log(reverseNum(nums))
    </code>
</pre>
<pre>
    <code>
const nums = 'Im Vivek Pathak';

const reverseNum = function myFun(arr){
   let word = nums.split(' ');
   let reverse = '';
   for(i=word.length-1; i>=0; i--){
       reverse = reverse + word[i] + ' ';
   }
   return reverse.trim();
}
console.log(reverseNum(nums));
    </code>
</pre>

 <pre>
    <code>
// Write a function to find the longest common prefix string amongst an array of strings.        
// Input: strs = ["flower","flow","flight"]
// Output: "fl"

function longestCommonPrefix(strs) {
  if (!strs.length) return "";

  let prefix = strs[0];

  for (let i = 1; i < strs.length; i++) {
    while (strs[i].indexOf(prefix) !== 0) {
      prefix = prefix.slice(0, -1); // remove last char
      if (!prefix) return "";
    }
  }

  return prefix;
}
    </code>
 </pre>

<pre>
  <code>
const nums = [0,1,2,0,3,0,4,5,6,7];

function myFun(num){
    let nonZero = 0;
      for(let i=0; i< num.length; i++){
          if(num[i] !==0){
              num[nonZero] = num[i];
              nonZero++
          }
      }
      for(let i = nonZero; i< num.length; i++){
          num[i] = 0;
      }
      return num;
}
console.log(myFun(nums));
//output [1, 2, 3, 4, 5, 6, 7, 0, 0, 0]
  </code>
</pre>

<pre>
  <code>
// Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.
// Input: nums = [2,2,1]
// Output: 1

const singleFun = function single(arr) {
    arr.sort((a, b) => a - b); // Sort the array first

    for (let i = 0; i < arr.length - 1; i += 2) {
        if (arr[i] !== arr[i + 1]) {
            return arr[i];
        }
    }
    return arr[arr.length - 1]; // Last element is the unique one
};

const nums = [1, 0, 1];
console.log(singleFun(nums)); // Output: 0

//OR 

let singleNumber = function(arr) {
    
   return arr.reduce((acc, num) => acc ^ num, 0);
};

  </code>
</pre>
<pre>
  <code>
// Given an integer array nums, return true if any value appears at least twice in the array,
//  and return false if every element is distinct.
// Input: nums = [1,2,3,1]
// Output: true

const singleFun = function single(arr) {
  arr.sort((a, b) => a - b); // sort the array

  for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] === arr[i + 1]) {
      return true; // duplicate found
    }
  }

  return false; // no duplicates
};

const nums = [1, 2, 2];
console.log(singleFun(nums)); // true
  </code>
</pre>
<pre>
  <code>
// Input: digits = [1,2,3]
// Output: [1,2,4]

function plusOne(digits) {
  for (let i = digits.length - 1; i >= 0; i--) {
    if (digits[i] < 9) {
      digits[i]++;       // Add one if digit is less than 9
      return digits;
    }
    digits[i] = 0;        // Set to 0 and carry over to next digit
  }

  // If all digits were 9, we need an extra 1 at the front
  digits.unshift(1);
  return digits;
}
  </code>
</pre>

<pre>
  <code>
//make any string as palindrome

let str = 'vivek';

const makePalindrome = function myFun1(){
    const addStr = str + str.split('').reverse().join('');
    return addStr === addStr.split('').reverse().join('');
}

console.log(makePalindrome(str));
  </code>
</pre>
<pre>
  <code>
// Given a string, write a function to count the occurrences of each character in the string.                       
const nums = ['app', 'bpp', 'cpp', 'cpp', 'app', 'bpp'];

const reverseNum = function myFun(arr){
    let count = {};
    for (let x of arr){
        count[x] = count[x] ? count[x] + 1 : 1;
    }
    return count;
}
console.log(reverseNum(nums));
  </code>
</pre>

<pre>
  <code>
function findMax(arr) {
// Initialize max to the first element of the array
let max = arr[0];
// Iterate through the array starting from the second element
for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
        max = arr[i];  // Update max if a larger element is found
    }
}
    return max;
}
// Example usage
const numbers1 = [10, 20, 5, 40, 25];
console.log(findMax(numbers1)); // Output: 40
  </code>
</pre>

<pre>
  <code>
// 3. Write a JavaScript function to check if a given string is a palindrome (reads the same forwards and backwards). 
const str = "jahaj";
function strPal(){
    if(str === str.split("").reverse().join("")){
        return "its a palindrome"
    }else{
        return "false"
    }
}
const check = strPal(str);
console.log(check);
// Testing
console.log(str.split("").reverse().join(""));
  </code>
</pre>
<pre>
  <code>
// 5. Write a JavaScript function that takes an array of numbers and returns a new array with only the even numbers  
const arryNum = [1,2,3,4,5,6,7,8,9]
function evenfun(){
    return arryNum.filter((num)=>{
        return num % 2 ===0
    })
}
console.log(evenfun());
  </code>
</pre>
<pre>
  <code>
// 6. Write a JavaScript program to calculate the factorial of a given number. 
const givenNum = 5;
function facNum(givenNum){
    let result = 1;
    for(let i=1; i<=givenNum; i++){
        result = result*i;
    }
    return result;
}  
console.log(facNum(5)) 
  </code>
</pre>
<pre>
  <code>
// 7. Write a JavaScript function to check if a given number is prime.
//  prime number means which is divisible by itself 0,1 is not a prime num and 2 is prime number 
let pNumber = 7;
function isPrime(){
    if(pNumber <=1){
        return false;
    } else if (pNumber===2) {
        return true;
    } else if (pNumber % 2 === 0){
        return false;
    }
    for (let i =2; i<=Math.sqrt(pNumber); i++){
        if(pNumber % i === 0) return false;
    }
    return "true";
} 
console.log(`this number ${pNumber} is prime`, isPrime())
  </code>
</pre>
<pre>
  <code>
// 10. Write a JavaScript program to convert a string to title case (capitalize the first letter of each word).
const strTitle = "my name is vivek pathak";
console.log(strTitle.split(' ').map((word)=>{
    return word.charAt(0).toUpperCase() + word.slice(1)
}).join(' '))
  </code>
</pre>
<pre>
  <code>
//12 5. Implement a function that takes a arrays and sort them without using any built-in sorting functions. 
                
function bubbleSort(arr) {
    for (let i = 0; i < arr.length; i++) {
      for (let j = 0; j < arr.length - i - 1; j++) {
        if (arr[j] > arr[j + 1]) {
          const lesser = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = lesser;
        }
      }
    }
    // return the sorted array
    return arr;
  }
  
console.log(bubbleSort([3, 4, 9, 3, 1]));
  </code>
</pre>

<pre>
  <code>
function mergeArrays(arr1, arr2) {
const result = [];
let index = 0;

  // Copy elements from first array
  for (let i = 0; i < arr1.length; i++) {
    result[index] = arr1[i];
    index++;
  }

  // Copy elements from second array
  for (let i = 0; i < arr2.length; i++) {
    result[index] = arr2[i];
    index++;
  }

  return result;
}
const sortedArray1 = [1, 3, 5, 7];
const sortedArray2 = [2, 4, 6, 8];
const result = mergeArrays(sortedArray1, sortedArray2);
console.log("Merged Sorted Array:", result);
//output Merged Sorted Array: [1, 3, 5, 7,2, 4, 6, 8]
  </code>
</pre>
<pre>
  <code>
//15 9. Write a function that determines if two strings are anagrams of each other  
function areAnagrams(str1, str2) {
    return str1.split("").sort().join("") === str2.split("").sort().join("");
}
// Example usage
console.log(areAnagrams("listen", "silent")); // true
console.log(areAnagrams("hello", "world"));   // false
  </code>
</pre>
<pre>
  <code>
//18 4. Write a function that takes an array of integers as input and returns a new array with only the unique elements. 
function getUniqueElements(arr) {
    const uniqueElements = [];

    for (let i = 0; i < arr.length; i++) {
        if (!uniqueElements.includes(arr[i])) {
            uniqueElements.push(arr[i]);
        }
    }

    return uniqueElements;
}
// Example usage
const numbers3 = [1, 2, 3, 1, 2, 4, 5, 6, 4];
const uniqueNumbers2 = getUniqueElements(numbers3);
console.log(uniqueNumbers2); // [1, 2, 3, 4, 5, 6]
  </code>
</pre>
<pre>
  <code>
//19 7. Implement a function to find the sum of all the numbers in an array.
function sumOfArray(arr) {
    return arr.reduce((sum, current) => sum + current, 0);
}

// Example usage
const numbersAll = [1, 2, 3, 4, 5];
const sum1 = sumOfArray(numbersAll);
console.log(sum1); // 15
  </code>
</pre>
<pre>
  <code>
let char = 'ABCXYZabcxyz123';
function myFun(length){
    let random = '';
    for(let i=0; i < length; i++){
        randomIndex = Math.floor(Math.random() * char.length);
        random = random + char[randomIndex];
    }
    return random;
}
console.log(myFun(5))
  </code>
</pre>
<pre>
  <code>
const nums = [1,2,3,4,5,6]
const random = function myFun(arr){
    for(let i = arr.length-1; i>=0; i--){
        let j = Math.floor(Math.random() * (i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]]
    }
    return arr
}
console.log(random(nums));

//OR

const random = function myFun(arr){
    return arr.sort(()=> Math.random() - 0.5)
}
console.log(random(nums));
  </code>
</pre>
<pre>
  <code>
//29. 5. Write a function that sorts an array of strings in alphabetical order.     
function sortStrings(arr) {
    return arr.slice().sort();
}
// Example usage
const strings = ["banana", "apple", "grape", "kiwi"];
console.log(sortStrings(strings)); // Output: ["apple", "banana", "grape", "kiwi"]
  </code>
</pre>
<pre>
  <code>
//31. 7. Write a function that removes all falsy values (false, null, 0, ‚Äú‚Äù, undefined, and NaN) from an array. 
function removeFalsyValues(arr) {
    return arr.filter(Boolean);
}
// Example usage
console.log(removeFalsyValues([0, 1, false, "", null, 2, undefined, 3])); 
// Output: [1, 2, 3]
  </code>
</pre>
<pre>
  <code>
//33. What are higher order functions, and what are their benefits?
const primes = [3, 5, 7, 11];
// pass a function to map
const doubledPrimes = primes.map((x) => x * 2);
console.log(doubledPrimes);
// expected output: Array [6, 10, 14, 22]
  </code>
</pre>
<pre>
  <code>
//34. Write a loop that prints every number divisible by 3 from 1-200:    
for (let i = 1; i < 201; i++) {
    if (i % 3 === 0) {
    }
    // console.log(i);
}          
  </code>
</pre>
<pre>
  <code>
let email = "example@gmail.com";
console.log(email.split('@').slice(0,1));
//output 'example' 
  </code>
</pre>
<pre>
  <code>
function myFun(){
let nums = [];
    
    for(let i =1; i < 51; i++){
        if(i % 2 === 0){
            nums.push('fizz')
        }else{
            nums.push('buzz')
        }
    }
    return nums;
}
console.log(myFun())
  </code>
</pre>
<pre>
  <code>
let landPlots = [
    { location: "A1", status: "Available" },
    { location: "B2", status: "Sold" },
    { location: "C3", status: "Available" },
    { location: "D4", status: "Sold" },
    { location: "E5", status: "Available" }
];
                      
const filterdata = landPlots.filter((data,index)=>{
    if(data.status === 'Sold'){
        return data.status = 'Unsold';
    }
});
console.log(filterdata);
                      
//output
[
  { location: 'B2', status: 'Unsold' },
  { location: 'D4', status: 'Unsold' }
]
  </code>
</pre>
<pre>
  <code>
const strs = 'Vivek';
function myFun(str){
    const vowels = 'aeiou';
    let count = 0;
    
    for(let x of str ){
        if(vowels.includes(x)){
            count++
        }
    }
    return count;
}
console.log(myFun(strs));
  </code>
</pre>
<pre>
<code>
function shuffleArr(arr) {
for (let i = arr.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // Random index from 0 to i
    [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap elements
}
return arr;
}  

//OR

//other method
            
function shuffleArr(arr) {
    return arr.sort(() => Math.random() - 0.5);
}
  </code>
</pre>
<pre>
  <code>
function isSorted(arr) {
for (let i = 0; i < arr.length - 1; i++) {
    if (arr[i] > arr[i + 1]) {
        return false;
    }
}
return true;
}
                        
// Example usage:
console.log(isSorted([1, 2, 3, 4, 5])); // true
console.log(isSorted([5, 3, 4, 1, 2])); // false
  </code>
</pre>
<pre>
  <code>
// Check if Two Objects are Equal
function isEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}

console.log(isEqual({ a: 1 }, { a: 1 })); // Output: true
console.log(isEqual({ a: 1 }, { b: 1 })); // Output: false
  </code>
</pre>

<pre>
  <code>
    // Group Objects by a Property
let items = [
  { category: "fruit", name: "Apple" },
  { category: "vegetable", name: "Carrot" },
  { category: "fruit", name: "Banana" }
];

let grouped = items.reduce((acc, item) => {
acc[item.category] = acc[item.category] || [];
acc[item.category].push(item.name);
return acc;
}, {});
                        
console.log(grouped);
// Output: { fruit: ["Apple", "Banana"], vegetable: ["Carrot"] }
  </code>
</pre>

<pre>
  <code>
     // Remove a Property from All Objects in an Array
let users = [
{ name: "Alice", age: 30, city: "NY" },
{ name: "Bob", age: 25, city: "LA" }
];
                        
users = users.map(({ city, ...rest }) => rest);
console.log(users);
                                          
// Check if Two Objects are Equal
  function isEqual(obj1, obj2) {
  return JSON.stringify(obj1) === JSON.stringify(obj2);
}
                        
console.log(isEqual({ a: 1 }, { a: 1 })); // Output: true
console.log(isEqual({ a: 1 }, { b: 1 })); // Output: false
                        
//  Freeze an Object to Prevent Modification
let obj = Object.freeze({ name: "Alice" });
obj.name = "Bob"; // No effect
console.log(obj.name); // Output: Alice
  </code>
</pre>

<pre>
  <code>
console.log({ a: 1 } === { a: 1 }) //False
console.log({ a: 1 } == { a: 1 })  //False
  </code>
</pre>

<pre>
  <code>
var foo = 1;
let bar = 2;
const baz = 3;

console.log(window.foo); // ‚úÖ 1
console.log(window.bar); // ‚ùå undefined
console.log(window.baz); // ‚ùå undefined
  </code>
</pre>

</div>


<!-- js questions -->
<div id="menu1" class="container-flui py-0 tab-pane">
<div>
  <pre>
    <code>
let fName = {
    name:"john"
}
var age;
function product(a, b) {
    age = a * b;
    return a * b;
}
console.log(age)  //UD
let result = product.call(this, 20, 5);
 
 
function profile(age1){
    return {
        ...fName,age1
    }
}
let age2 = profile.call(this.age)
console.log(result,age2);

//output
=>undefined
=>100 { name: 'john', age1: undefined }
    </code>
  </pre>

  <pre>
    <code>
let arr = [
  {name:"a",age:21},{name:"b",age:20},{name:"c",age:30},{name:"d",age:30}
];

// console.log(arr.find((item)=>item.age < 30))
// output => { name: 'a', age: 21 }

// console.log(arr.find((item)=>item.age < 10))
// output => undefind
    </code>
  </pre>
  <pre>
    <code>
console.log([] == []);  // false
console.log({} == {}); // false

console.log([] === []); // false
console.log({} === {}); // false

//Explain
| Expression    | Result | Why                         |
| ------------- | ------ | --------------------------- |
| `[] == []`    | false  | Different array references  |
| `{}` == `{}`  | false  | Different object references |
| `[] === []`   | false  | Same as above               |
| `{}` === `{}` | false  | Same as above               |

    </code>
  </pre>
<pre>
  <code>
console.log(NaN === NaN); //false
console.log(undefined === undefined); //true
console.log(null === null); // true
console.log(Object === Object); // true
console.log(Number.isNaN(NaN)); // true (use this to check NaN)
console.log(new Object() === new Object()); // false


  </code>
</pre>  
<pre>
  <code>
// üåê What Are Web Accessibility Standards?
=> Web accessibility standards are guidelines and best practices that ensure websites
   and web applications are usable by everyone, including people with disabilities (e.g., visual, auditory, motor, cognitive impairments).
  
//üõ†Ô∏è What Is the Ability to Build Accessible User Interfaces?
=> Building accessible UIs means designing and developing websites or apps so that all users can access and interact with them, regardless of disabilities.

// This includes:

=> ‚úÖ Techniques & Best Practices
// Semantic HTML
=> Use elements like < button>, < nav>, < main>, < label>, < form>, etc., for meaning‚Äînot just layout.

// ARIA (Accessible Rich Internet Applications)
=> Add roles and properties (e.g., role="dialog", aria-label) to enhance accessibility, especially for screen readers.

// Keyboard Navigation
=> Ensure all interactive elements are accessible via the keyboard (e.g., Tab, Enter, Esc).

// Color Contrast
=> Use high contrast between text and background (WCAG recommends a 4.5:1 ratio for normal text).

// Alt Text for Images
=> Provide alt attributes so screen readers can describe the image content.

// Accessible Forms
=> Ensure every input field has a label, and provide clear validation messages.

// Screen Reader Testing
=> Test your site using screen readers like NVDA, VoiceOver, or JAWS.

// Responsive & Zoomable Layouts
=>Allow users to scale text and layout without breaking the UI. 


// Why It Matters
=> Legal Compliance: Avoid lawsuits (e.g., ADA compliance in the U.S.)
=> Inclusivity: You serve a wider audience, including ~15% of the global population with disabilities
=> SEO & UX Benefits: Accessible sites are often better structured and more usable for everyone
  
  </code>
</pre>

<pre>
  <code>
// how to do frontend performance optimization   
=> Front-end performance optimization is about improving how fast and efficiently a web page loads and
   responds to user interactions. A faster site improves user experience, SEO rankings, and conversion rates. 

// üöÄ 1. Optimize Assets
// üñºÔ∏è Images
=> Use modern formats: WebP, AVIF
=> Compress images (TinyPNG, ImageOptim)
=> Use responsive images (<picture>, srcset)
=> Lazy-load below-the-fold images (loading="lazy")

// üì¶ CSS & JS
=> Minify CSS, JS, and HTML
=> Combine files where possible to reduce HTTP requests
=> Remove unused CSS (PurgeCSS, Tailwind‚Äôs tree-shaking)
=> Split large JS bundles (code-splitting with Webpack/Vite)

// ‚öôÔ∏è 2. Leverage Browser Caching
=> Set proper Cache-Control and ETag headers for static assets so they‚Äôre stored and reused by the browser.

// üåê 3. Use a CDN (Content Delivery Network)
=> Serve static assets (images, fonts, JS/CSS) through a CDN like Cloudflare, Akamai, or AWS CloudFront to reduce latency.

// ‚ö° 4. Reduce Initial Load Time
// ‚è±Ô∏è Lazy Load Non-Critical Assets
  => Lazy-load images, videos, and third-party scripts
  => Defer non-critical JS with async or defer

// ‚úÇÔ∏è Tree Shaking
  => Remove unused JS code (ES6 modules + tools like Webpack/Rollup support this)

//üß† Critical CSS
  =>Inline only the CSS required to render above-the-fold content

// üîÉ 5. Optimize JavaScript Execution
=> Avoid heavy computations on the main thread
=> Use web workers for background tasks
=> Debounce or throttle expensive event handlers (like scroll, resize)

// üõë 6. Reduce Repaints & Reflows
=> Avoid layout thrashing (e.g., accessing and modifying DOM styles in a loop)
=> Use CSS transforms and opacity for animations (GPU-accelerated)
=> Minimize DOM depth and complexity

// üìâ 7. Optimize Fonts
=> Use only needed font weights and subsets
=> Use font-display: swap to avoid invisible text during loading
=> Serve fonts via a CDN






‚úÖ Final Checklist

=> Compress & optimize images
=> Minify and lazy-load JS/CSS
=> Use a CDN
=> Inline critical CSS
=> Reduce third-party scripts
=> Monitor and continuously optimize with tools   
  </code>
</pre>

<pre>
<code>
// What is this?

=> In JavaScript, the this keyword refers to an object.
=> The this keyword refers to different objects depending on how it is used:

=> In an object method, this refers to the object.
    //this in a Method
    => When used in an object method, this refers to the object.
    => In the example on top of this page, this refers to the person object.
    => Because the fullName method is a method of the person object.
    const person = {
        firstName: "John",
        lastName : "Doe",
        id       : 5566,
        fullName : function() {
            return this.firstName + " " + this.lastName;
        }
    };

=> Alone, this refers to the global object.
    //this Alone
    => When used alone, this refers to the global object.
    => Because this is running in the global scope.
    => In a browser window the global object is [object Window]:
    //ex
    let x = this;
    // output => [object Window]
    => In strict mode, when used alone, this also refers to the global object:
    "use strict";
    let x = this; => same output

=> In a function, this refers to the global object.
    // this in a Function (Default)
    => In a function, the global object is the default binding for this.
    => In a browser window the global object is [object Window]:

    function myFunction() {
            return this;
        }
    myFunction()
    output=> [object Window]

=> In a function, in strict mode, this is undefined.    
    // this in a Function (Strict)
    => JavaScript strict mode does not allow default binding.
    => So, when used in a function, in strict mode, this is undefined.

    "use strict";
    function myFunction() {
            return this;
        }
    myFunction()
    output=> [object Window]


=> In an event, this refers to the element that received the event.
    // this in Event Handlers
    => In HTML event handlers, this refers to the HTML element that received the event:
    < button onclick="this.style.display='none'">
        Click to Remove Me!
    < /button>



=> Methods like call(), apply(), and bind() can refer this to any object.
    // Object Method Binding
    => In these examples, this is the person object:
    const person = {
        firstName  : "John",
        lastName   : "Doe",
        id     : 5566,
        myFunction : function() {
            return this;
        }
    };
    person.myFunction()
    //output => [object Object]

    //example2
    const person = {
        firstName: "John",
        lastName: "Doe",
        id: 5566,
        fullName : function() {
            return this.firstName + " " + this.lastName;
        }
    };
    person.fullName()
    //output => John Doe
    // i.e. this.firstName is the firstName property of this (the person object).

    //example3
    => The example below calls person1.fullName with person2 as an argument, this refers to person2, even if fullName is a method of person1:
    
    const person1 = {
        fullName: function() {
            return this.firstName + " " + this.lastName;
        }
    }

    const person2 = {
        firstName:"John",
        lastName: "Doe",
    }

    person1.fullName.call(person2); 
    //output => John Doe
    //In this example this refers to person2, even if it is a method of person1:

    //example3
    // Function Borrowing

    => With the bind() method, an object can borrow a method from another object.
    => This example creates 2 objects (person and member).
    => The member object borrows the fullname method from the person object:

    const person = {
        firstName:"John",
        lastName: "Doe",
        fullName: function() {
            return this.firstName + " " + this.lastName;
        }
    }

    const member = {
        firstName:"Hege",
        lastName: "Nilsen",
    }

    person.fullName.bind(member);
    //output => Hege Nilsen

</code>
</pre>

<pre>
<code>
// The JavaScript call() Method
=> The call() method is a predefined JavaScript method.
=> It can be used to invoke (call) a method with an object as an argument (parameter).
//OR
=> With call(), an object can use a method belonging to another object.


//example
const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
const person2 = {
  firstName:"Mary",
  lastName: "Doe"
}
// This will return "John Doe":
person.fullName.call(person1);

//OR

const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
const person2 = {
  firstName:"Mary",
  lastName: "Doe"
}

// This will return "Mary Doe"
person.fullName.call(person2);


//The call() Method with Arguments
=> The call() method takes arguments separately.
const person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}

const person1 = {
  firstName:"John",
  lastName: "Doe"
}
person.fullName.call(person1, "Oslo", "Norway");


// The JavaScript apply() Method
=> The apply() method is similar to the call() method but its takes argument as an array.
=> In this example the fullName method of person is applied on person1:

//example
const person = {
  fullName: function() {
    return this.firstName + " " + this.lastName;
  }
}
const person1 = {
  firstName: "Mary",
  lastName: "Doe"
}
// This will return "Mary Doe":
person.fullName.apply(person1);

//OR

const person = {
  fullName: function(city, country) {
    return this.firstName + " " + this.lastName + "," + city + "," + country;
  }
}
const person1 = {
  firstName:"John",
  lastName: "Doe"
}
person.fullName.apply(person1, ["Oslo", "Norway"]);


//Function Borrowing
=> With the bind() method, an object can borrow a method from another object.
=> The example below creates 2 objects (person and member).
=> The member object borrows the fullname method from the person object:

//example
const person = {
  firstName:"John",
  lastName: "Doe",
  fullName: function () {
    return this.firstName + " " + this.lastName;
  }
}
const member = {
  firstName:"Hege",
  lastName: "Nilsen",
}
let fullName = person.fullName.bind(member);
//output=> Hege Nilsen


// Preserving(‡§∏‡§Ç‡§∞‡§ï‡•ç‡§∑‡§£) this = Use of bind()
=> Sometimes the bind() method has to be used to prevent losing this.

//example
const person = {
  firstName:"John",
  lastName: "Doe",
  display: function () {
    let x = document.getElementById("demo");
    x.innerHTML = this.firstName + " " + this.lastName;
  }
}
person.display();
// output = John Doe

// but

=> When a function is used as a callback, this is lost.
=> This example will try to display the person name after 3 seconds, but it will display undefined instead:

const person = {
  firstName:"John",
  lastName: "Doe",
  display: function () {
    let x = document.getElementById("demo");
    x.innerHTML = this.firstName + " " + this.lastName;
  }
}

setTimeout(person.display, 3000);
//output willl be undefined, undefind

=> The bind() method solves this problem.

const person = {
  firstName:"John",
  lastName: "Doe",
  display: function () {
    let x = document.getElementById("demo");
    x.innerHTML = this.firstName + " " + this.lastName;
  }
}

let display = person.display.bind(person);
setTimeout(display, 3000);

// Now output will be print John Doe after 3 seconds
</code>
</pre>
    
<pre>
<code>
// JavaScript Closures

//example closure
function outer(){
    var name = "Vivek";
    function inner(){
      
        console.log('my name is...', name);
    }
    inner();
}
outer();


=> JavaScript variables can belong to:
=> The local scope or The global scope
=> Global variables can be made local (private) with closures.
=> Closures makes it possible for a function to have "private" variables.  

// Local Variables

=> A local variable is a "private" variable defined inside a function.
=> A function can access all variables in the local scope.
//Example
function myFunction() {
  let a = 4;
  return console.log(a*a);
}
myFunction();
//output will br 16

// Global Variables

=> A global variable is a "public" variable defined outside a function.
=> A function can access all variables in the global scope:
//Example
let a = 4;
function myFunction() {

  return console.log(a*a);
}
myFunction();

// Note
=> Undeclared variables (created without a keyword var, let, const), are always global, even if they are created inside a function.
function myFunction() {
  a = 4;
}
myFunction();
console.log(a*a);
//output = 16

</code>    
</pre>

<pre>                         
<code>
// var allows re-declaration
var a = 1;
var a = 2; // ‚úÖ OK

// let does not
let b = 1;
// let b = 2; ‚ùå SyntaxError

// const does not
const c = 1;
// const c = 2; ‚ùå SyntaxError

// let allows reassignment
b = 3; // ‚úÖ

// const does not
// c = 4; ‚ùå TypeError


//Even though const can't be reassigned, objects and arrays declared with const can still be mutated: --&gt;
            
const user = { name: "Alice" };
user.name = "Bob"; // ‚úÖ Allowed

const arr = [1, 2, 3];
arr.push(4);       // ‚úÖ Allowed

// But reassignment is not allowed
// user = { name: "Charlie" }; ‚ùå TypeError


<!-- Global Object (e.g., window) -->
var foo = 1;
let bar = 2;
const baz = 3;

console.log(window.foo); // ‚úÖ 1
console.log(window.bar); // ‚ùå undefined
console.log(window.baz); // ‚ùå undefined
</code>
</pre>

<pre>
<code>
//What is An Event Loop in JavaScript?
=>The event loop is an important concept in JavaScript that enables asynchronous programming by handling tasks efficiently. 
  Since JavaScript is single-threaded, it uses the event loop to manage the execution of multiple tasks without blocking the main thread.

    //example
    console.log("Start");

    setTimeout(() => {
        console.log("setTimeout Callback");
    }, 0);

    Promise.resolve().then(() => {
        console.log("Promise Resolved");
    });

    console.log("End");

    //output
    Start
    End
    Promise Resolved
    setTimeout Callback

    //Explanation
    //In this example

    =>console.log("Start") executes first.
    =>setTimeout schedules its callback but does not execute it immediately.
    =>Promise.resolve().then() is placed in the microtask queue and executes before the callback queue.
    =>Promise Resolved appears before setTimeout Callback due to microtask priority.
    
    // explanation2
    => "Start" and "End" are synchronous, so they run immediately.
    => Promise.then goes to the microtask queue.
    => setTimeout goes to the macrotask queue.
    => After the synchronous code ends:
    => Microtasks (Promise) are executed first.
    => Then the macrotask (Timeout) is executed.

JavaScript executes code synchronously in a single thread. However, 
it can handle asynchronous operations such as fetching data from an API, 
handling user events, or setting timeouts without pausing execution. 
This is made possible by the event loop.  

//How the Event Loop Works
=> The event loop continuously checks whether the call stack is empty and
   whether there are pending tasks in the callback queue or microtask queue.
<img src="./images/img-js/Event-Loop-in-JavaScript.jpg" alt="">  

=> <b>Call Stack</b>: JavaScript has a call stack where function execution is managed in a Last-In, First-Out (LIFO) order.
=> <b>Web APIs (or Background Tasks)</b>: These include setTimeout, setInterval, fetch, DOM events, and other non-blocking operations.
=> <b>Callback Queue (Task Queue)</b>: When an asynchronous operation is completed, its callback is pushed into the task queue.
=> <b>Microtask Queue:</b> Promises and other microtasks go into the microtask queue, which is processed before the task queue.
=> <b>Event Loop:</b> It continuously checks the call stack and, if empty, moves tasks from the queue to the stack for execution.

//Why is the Event Loop Important?
=> Non-blocking Execution: Enables JavaScript to handle multiple tasks efficiently.
=> Better Performance: Ensures UI updates and API calls do not freeze the page.
=> Optimized Async Handling: Prioritizes microtasks over macrotasks for better responsiveness.

<table border="1">
<thead>
  <tr>
    <th>Method</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><code>Promise.resolve()</code></td>
    <td>Creates a resolved promise</td>
  </tr>
  <tr>
    <td><code>Promise.reject()</code></td>
    <td>Creates a rejected promise</td>
  </tr>
  <tr>
    <td><code>Promise.all()</code></td>
    <td>Waits for all promises to resolve</td>
  </tr>
  <tr>
    <td><code>Promise.allSettled()</code></td>
    <td>Waits for all to settle, resolves with result objects</td>
  </tr>
  <tr>
    <td><code>Promise.race()</code></td>
    <td>Resolves/rejects with the first settled promise</td>
  </tr>
  <tr>
    <td><code>Promise.any()</code></td>
    <td>Resolves with first fulfilled, rejects only if all fail</td>
  </tr>
</tbody>
</table>
</code>
</pre>

<pre>
    <code>
//MicroTask vs MacroTask        
    console.log("1");

    setTimeout(() => {
    console.log("2 - setTimeout (macrotask)");
    }, 0);

    Promise.resolve().then(() => {
    console.log("3 - Promise.then (microtask)");
    });

    console.log("4");

    //output
    1
    4
    3 - Promise.then (microtask)
    2 - setTimeout (macrotask)
    </code>
</pre>

<pre>
    <code>
// What is Prototypal Inheritance?
=> Prototypal Inheritance is a mechanism in JavaScript where objects inherit directly from other objects. Each object has an internal link to another object
   called its prototype, forming a prototype chain.

   // 1. __proto__ and the Prototype Chain
   => Every object in JavaScript has a hidden property called [[Prototype]] (accessible as __proto__) that points to another object.
   => If a property is not found on the object, JavaScript looks up the prototype chain until it finds it or reaches null.

   const animal = {
    speak() {
        console.log("Animal speaks");
    },
    };

    const dog = {
    bark() {
        console.log("Woof!");
    },
    };

    dog.__proto__ = animal;

    dog.speak(); // Animal speaks
    => üîÅ Prototype Chain: dog ‚Üí animal ‚Üí Object.prototype ‚Üí null

    // 2. Object.create() for Inheritance
T       => his method creates a new object and sets its prototype.
        const parent = {
            greet() {
                console.log("Hello from parent");
            },
        };

        const child = Object.create(parent);
        child.greet(); // Hello from parent
        => Simple and powerful way to implement inheritance without classes.

    // 3. Class-based Inheritance (ES6)
    => JavaScript introduced class syntax in ES6. Under the hood, it still uses prototypes, but the syntax is more familiar
       to developers from class-based languages like Java or C#.
       class Animal {
        speak() {
            console.log("Animal speaks");
        }
        }

        class Dog extends Animal {
        bark() {
            console.log("Woof!");
        }
        }

        const d = new Dog();
        d.speak(); // Animal speaks
        d.bark();  // Woof!

        => üîç Internally, this creates a prototype chain just like before:
        => d ‚Üí Dog.prototype ‚Üí Animal.prototype ‚Üí Object.prototype ‚Üí null


    </code>
</pre>

<pre>
<code>
// üîç 9. Explain Debouncing and Throttling in JavaScript
=> Both debouncing and throttling are performance optimization techniques used to control how often
   a function executes in response to high-frequency events like:
   * scroll
   * resize
   * mousemove
   * keyup / input

//‚öôÔ∏è Debouncing
// ‚úÖ Definition:
=> Debouncing ensures a function is executed only once after a specified delay after the last event.
=> If the event keeps firing, the timer resets.

//üìå Use case:
=> Search input field (trigger API only when user stops typing)
=> Resize event handler

//example

    function debounce(func, delay) {
    let timer;
    return function (...args) {
        clearTimeout(timer); // Clear existing timer
        timer = setTimeout(() => {
        func.apply(this, args);
        }, delay);
    };
    }

// Usage
window.addEventListener("resize", debounce(() => {
console.log("Resize event handled");
}, 300));
=>The function only runs after 300ms have passed since the last resize event.


// ‚öôÔ∏è Throttling
// ‚úÖ Definition:
=> Throttling ensures a function is executed at most once every specified interval, 
   regardless of how often the event fires.

// üìå Use case:
=> Scroll position tracking
=> Auto-save every 2 seconds while typing
=> Limiting button click handlers

//example
    function throttle(func, limit) {
      let lastCall = 0;
      return function (...args) {
        const now = Date.now();
        if (now - lastCall >= limit) {
          lastCall = now;
          func.apply(this, args);
        }
      };
    }

// Usage
window.addEventListener("scroll", throttle(() => {
  console.log("Scroll event handled");
}, 200));
=> The function runs at most once every 200ms, even if the scroll event fires constantly.

| Feature       | Debounce                     | Throttle                      |
| ------------- | ---------------------------- | ----------------------------- |
| Function runs | After the last event (waits) | At regular intervals          |
| Use case      | Search input, window resize  | Scroll, drag, button spamming |
| Behavior      | Delays execution until stop  | Restricts execution frequency |
| Timer resets? | Yes, on every event          | No, runs on fixed interval    |

// ‚úÖ Summary:

=> Use debouncing when you want the action to happen after the user is done (e.g., typing).
=> Use throttling when you want to limit how often a function runs during continuous events (e.g., scrolling).

</code>
</pre>

<pre>
    <code>
// Regular function
// Defining a regular function
    function greet(name) {
        console.log('Hello, ' + name + '!');
    }

    // Calling the function
    greet('Geek');

    //Output
    Hello, Geek!


    // 1. Access arguments with Regular functions
    function showArgs() {
        console.log(arguments);
    }
    showArgs(1, 2, 3);

    //Output
    [Arguments] { '0': 1, '1': 2, '2': 3 }

    // 2. Duplicate named parameters in Regular functions
        function example(a, b, a) {
            console.log(a, b);
        }
    example(1, 2, 3);

       // Output
        3 2   
        
    // 3. Hosting in Regular functions   

    greet(); // Output: Hello Geeks!

    function greet() {
        console.log('Hello Geeks!');
    } 

    //Output
    Hello Geeks!

    // 4. Using this keyword in Regular function
    const obj = {
        name: 'Geeks',
        greet: function() {
            console.log(this.name);
        }
    };
    obj.greet();

    //Output
    //Geeks


// Arrow function

// Defining an arrow function
const greet = (name) => {
    console.log(`Hello, ${name}!`);
};

// Calling the function
greet('Geeks');

// Output
// Hello, Geeks!

// 1. Access arguments with Arrow functions

const showArgs = (...args) => {
    console.log(args);
};
showArgs(1, 2, 3);

// Output
[ 1, 2, 3 ]


// 2. Duplicate named parameters in Arrow functions
const example = (a, b, a) => {
    console.log(a);
}; 
// SyntaxError: Duplicate parameter name not allowed in this context


// 3. Hoisting in Arrow functions
greet(); // ReferenceError: Cannot access 'greet' before initialization

const greet = () => {
    console.log('Hello!');
};

// Output:
// ReferenceError: Cannot access 'greet' before initialization


// 4. Using this keyword with Arrow function
const obj = {
    name: 'Geeks',
    greet: () => {
        console.log(this.name);
    }
};
obj.greet(); 
// Output: undefined (inherited from outer scope)
    </code>
</pre>


<pre>
  <code>
// What is Debouncing in JavaScript?
=> Debouncing in JavaScript can be defined as the technique that is used to limit the number of times a function gets executed.
   Debouncing is useful when the event is frequently being triggered in a short interval of time like typing, scrolling, and resizing.

// Debounce function
  function debounce(func, delay) {
      let timeout;
      return function (...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
              func.apply(this, args);
          }, delay);
      };
  }

// Function to be debounced
  function search(query) {
      console.log('Searching for:', query);
  }

// Create a debounced version of the search function
  const dSearch = debounce(search, 100);

// Simulate typing with multiple calls to the debounced function
  dSearch('Hello');
  dSearch('Hello, ');
  dSearch('Hello, World!');  // Only this call will trigger after 100ms
  // Output
  => Searching for: Hello, World!
  </code>
</pre>

<h5 class="mt-3">Promises</h5>
<pre>
  <code>
//What is a Promise in JavaScript?
A Promise is a JavaScript object that represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.

It allows you to write asynchronous code in a more readable and manageable way than callbacks.       

// Benefits of Promises

Cleaner syntax for async operations
Easier to chain multiple async tasks
Centralized error handling with .catch()
Helps avoid callback hell     

//üìå States of a Promise
State ||	Description
pending || Initial state; neither fulfilled nor rejected
fulfilled ||	Operation completed successfully
rejected ||	Operation failed


‚úÖ Basic Syntax
const promise = new Promise((resolve, reject) =&gt; {
  // async operation
  let success = true;

  if (success) {
    resolve("Operation successful!");
  } else {
    reject("Something went wrong.");
  }
});


//Consuming a Promise

promise
  .then(result =&gt; {
    console.log(result); // if resolved
  })
  .catch(error =&gt; {
    console.error(error); // if rejected
  });


// Real Example with setTimeout
 
  function fetchData() {
    return new Promise((resolve, reject) =&gt; {
      setTimeout(() =&gt; {
        resolve("Data fetched!");
      }, 2000);
    });
  }
  
  fetchData()
    .then(data =&gt; console.log(data))    // Output after 2s: Data fetched!
    .catch(err =&gt; console.error(err));
</code>
</pre>

<pre>
<code>

// In JavaScript, Promises are a way to handle asynchronous operations. A Promise represents a value that may be available now, or in the future, or never. It helps to deal with operations such as fetching data from an API, reading files, or waiting for a timer to complete without blocking the execution of other code.

// Key States of a Promise:
// A promise can be in one of three states:

// Pending: The initial state; the promise is neither fulfilled nor rejected.
// Fulfilled: The operation completed successfully, and the result is available.
// Rejected: The operation failed, and an error or reason is available.


// let firstPromise = new Promise( (resolve, reject) =&gt; {

//     setTimeout(function sayMyName() {
//         console.log("My Name is Love babbar");
//     }, 0);
// } );

let promise1 = new Promise((resolve, reject)=&gt; {
    let success = true;
    if(success) {
        resolve(10);
    }
    else {
        reject("Internal Server Error");
    }
});

promise1.then((message)=&gt; {
    console.log("first msg:" + message);
    return 20;
}).then((message)=&gt; {
    console.log("second msg: " + message);
    return 30;
}).then((message)=&gt; {
    console.log("third msg: " + message);
}).catch((error) =&gt; {
    console.error(error);
}).finally((message) =&gt; {
    console.log("Main to final hu, chalunga pakka")
})




// promise1.then((message) =&gt; {
//     console.log("Then ka message is " + message);
// }).catch((error)=&gt; {
//     console.log("Error: " + error);
// })


// let promise1 = new Promise((resolve, reject)=&gt; {
//     setTimeout(resolve, 1000, "First");
// })
// let promise2 = new Promise((resolve, reject)=&gt; {
//     setTimeout(resolve, 2000, "Second");
// })
// let promise3 = new Promise((resolve, reject)=&gt; {
//     setTimeout(reject, 4000, "Third");
// })

// Promise.all([promise3, promise2, promise1])
// .then((values) =&gt; {
//     console.log(values);
// })
// .catch((error)=&gt; {
//     console.error("error:" + error);
// })
</code>
</pre>

<h5 class="mt-3">Function Currying</h5>
<pre>
<code>
// Currying is used in JavaScript to break down complex function calls into smaller, 
   more manageable steps. It transforms a function with multiple arguments into a series
   of functions, each taking a single argument.

    => It converts a function with multiple parameters into a sequence of functions.
    => Each function takes a single argument and returns another function until all arguments are received.
  
  //example 
  function fun(a){
      return function(b){
          return function(c){
              return a+b+c;
          }
      }
  }
  fun(3)(4)(5);
  console.log(fun(3)(4)(5));  
  //output 
  =>12

  //example 2
  function myMail(to){
    return function(subject){
        return function(body){
            return `${to} and ${subject} and ${body}`
        }
    }
  }
  myMail('to Interviewer')('subject: front-end')('body: Hey Sir May I know the feedback');
  console.log(myMail('to Interviewer')('subject: front-end')('body: Hey Sir May I know the feedback'));

  //output
  => to Interviewer and subject: front-end and body: Hey Sir May I know the feedback

// Advantages of Currying Function
=> It helps us to create a higher-order function
=> It reduces the chances of error in our function by dividing it into multiple smaller functions that can handle one responsibility.
=> It is very useful in building modular and reusable code
=> It helps us to avoid passing the same variable multiple times
=> It makes the code more readable

</code>
</pre>


<h5 class="mt-3">shallow copy vs deep copy javascript</h5>
<pre>
  <code>
// Shallow Copy
=> A shallow copy creates a new object or array but only copies the top-level elements. 
   If the original object contains nested objects or arrays, the copied object will reference the same nested structures as the original. 
   This means that if you modify a nested object in either the original or the copied object, the changes will be reflected in both.
   copying in JavaScript include: Spread syntax (...), Object.assign()

// Example 
  const originalObject = {
    name: 'John',
    address: {
      city: 'New York',
    },
  };

  const shallowCopy = { ...originalObject };
  shallowCopy.name = 'Jane'; // Changes only the shallow copy
  shallowCopy.address.city = 'Los Angeles'; // Changes both original and shallow copy
  console.log(originalObject.name); // Output: John
  console.log(originalObject.address.city); // Output: Los Angeles

  // Deep Copy
  A deep copy creates a completely independent copy of the original object, including all 
  nested objects. If the original object contains nested objects, the copied object will 
  contain new copies of those nested objects. This means that modifying a nested object in 
  either the original or the copied object will not affect the other.
  
  // Common methods for creating deep copies in JavaScript include:
  JSON.parse(JSON.stringify(object)) (This method has limitations, as it does not copy functions or handle circular references)
  structuredClone() (This method is generally preferred for deep copying, but it may not be supported in all environments
  
  // Example
  const originalObject = {
    name: 'John',
    address: {
      city: 'New York',
    },
  };

  const deepCopy = structuredClone(originalObject);
  deepCopy.name = 'Jane'; // Changes only the deep copy
  deepCopy.address.city = 'Los Angeles'; // Changes only the deep copy
  console.log(originalObject.name); // Output: John
  console.log(originalObject.address.city); // Output: New York

</code>
</pre>


<h5 class="mt-3">Rest n Spread</h5>
<pre>                                
<code>
‚úÖ 6. Rest and Spread Operators (...)
The rest operator (...) in JavaScript is used to collect multiple arguments into a single array. It's especially useful in functions when you don't know how many arguments will be passed.

Rest gathers remaining elements.

Spread expands elements.

// Rest
function sum(...nums) {
  return nums.reduce((a, b) =&gt; a + b);
}

// Spread
const arr = [1, 2];
const newArr = [...arr, 3, 4];

//‚úÖ 4. Destructuring Assignment
Extract values from arrays or objects.

// Object
const user = { name: 'Alice', age: 25 };
const { name, age } = user;

// Array
const [first, second] = [10, 20];


// ‚úÖ 9. Modules (import / export)

// In file.js
export const PI = 3.14;

// In another file
import { PI } from './file.js';
</code>
</pre>

<h5 class="mt-3">Slice vs Splice</h5>
<pre>
  <code>
// Slice
=> Purpose: Extracts a section of an array (or string) and returns a new array (or string). 
   The original array (or string) remains unchanged.  
   
  => For Arrays: arr.slice(startIndex, endIndex)
  => For Strings: str.slice(startIndex, endIndex)

// const fruits = ['apple', 'banana', 'cherry', 'date', 'elderberry'];

// 1. Extracting from a specific start to the end
  const citrus = fruits.slice(2); // Starts at index 2 ('cherry') and goes to the end
  console.log(citrus);             // Output: ['cherry', 'date', 'elderberry']
  console.log(fruits);             // Output: ['apple', 'banana', 'cherry', 'date', 'elderberry'] (original unchanged)

// 2. Extracting within a range
  const tropical = fruits.slice(1, 4); // Starts at index 1 ('banana'), ends BEFORE index 4 ('elderberry')
  console.log(tropical);           // Output: ['banana', 'cherry', 'date']
  console.log(fruits);             // Output: ['apple', 'banana', 'cherry', 'date', 'elderberry'] (original unchanged)

// 3. Using negative indices
  const lastTwo = fruits.slice(-2); // Starts 2 from the end ('date') to the end
  console.log(lastTwo);            // Output: ['date', 'elderberry']

  const middlePart = fruits.slice(-4, -1); // Starts 4 from end ('banana'), ends BEFORE 1 from end ('elderberry')
  console.log(middlePart);         // Output: ['banana', 'cherry', 'date']

// 4. No arguments (creates a shallow copy of the entire array)
  const copyFruits = fruits.slice();
  console.log(copyFruits);         // Output: ['apple', 'banana', 'cherry', 'date', 'elderberry']
  console.log(copyFruits === fruits); // Output: false (it's a new array, but elements are shallow copied)
  
// splice()
=> Purpose: Changes the contents of an array by removing existing 
   elements and/or adding new elements. It modifies the original array in place.

  => arr.splice(startIndex, deleteCount, item1, item2, ...)

// Example

let colors = ['red', 'green', 'blue', 'yellow', 'purple'];

// 1. Deleting elements
const removedColors1 = colors.splice(1, 2); // Remove 2 elements starting from index 1 ('green', 'blue')
console.log(colors);          // Output: ['red', 'yellow', 'purple'] (original array modified)
console.log(removedColors1);  // Output: ['green', 'blue'] (the removed elements)

colors = ['red', 'green', 'blue', 'yellow', 'purple']; // Reset for next example

// 2. Adding elements (deleteCount is 0)
const addedColors = colors.splice(2, 0, 'orange', 'pink'); // At index 2, remove 0 elements, add 'orange', 'pink'
console.log(colors);          // Output: ['red', 'green', 'orange', 'pink', 'blue', 'yellow', 'purple']
console.log(addedColors);     // Output: [] (no elements were removed)

colors = ['red', 'green', 'blue', 'yellow', 'purple']; // Reset

// 3. Replacing elements (delete and add)
const replacedColors = colors.splice(1, 1, 'cyan'); // At index 1, remove 1 element ('green'), add 'cyan'
console.log(colors);          // Output: ['red', 'cyan', 'blue', 'yellow', 'purple']
console.log(replacedColors);  // Output: ['green'] (the removed element)

colors = ['red', 'green', 'blue', 'yellow', 'purple']; // Reset

// 4. Deleting from a specific index to the end
const remainingColors = colors.splice(3); // Remove all elements from index 3 ('yellow') to the end
console.log(colors);          // Output: ['red', 'green', 'blue']
console.log(remainingColors); // Output: ['yellow', 'purple']

colors = ['red', 'green', 'blue']; // Reset

// 5. Using negative startIndex
colors.splice(-1, 0, 'orange'); // At 1 from the end ('blue'), remove 0, add 'orange'
console.log(colors);           // Output: ['red', 'green', 'orange', 'blue']
</code>
</pre>

<pre> 
<code>
let landPlots = [
  { location: "A1", status: "Available" },
  { location: "B2", status: "Sold" },
  { location: "C3", status: "Available" },
  { location: "D4", status: "Sold" },
  { location: "E5", status: "Available" }
];
        
const filterdata = landPlots.filter((data,index)=&gt;{
    if(data.status === 'Sold'){
        return data.status = 'Unsold';
    }
});
console.log(filterdata);
            
//output
[
  { location: 'B2', status: 'Unsold' },
  { location: 'D4', status: 'Unsold' }
]
</code>
</pre>
<pre>                
<code>
function fizzBuzz() {
    let nums = [];

    for (let i = 1; i &lt;= 50; i++) {
    if (i % 3 === 0) {
        nums.push('fizz');
    } else {
        nums.push('buzz');
    }
    }
    return nums;
}
console.log(fizzBuzz())
/// output
[
    'buzz', 'buzz', 'fizz', 'buzz', 'buzz',
    'fizz', 'buzz', 'buzz', 'fizz', 'buzz',
    'buzz', 'fizz', 'buzz', 'buzz', 'fizz',
    'buzz', 'buzz', 'fizz', 'buzz', 'buzz',
    'fizz', 'buzz', 'buzz', 'fizz', 'buzz',
    'buzz', 'fizz', 'buzz', 'buzz', 'fizz',
    'buzz', 'buzz', 'fizz', 'buzz', 'buzz',
    'fizz', 'buzz', 'buzz', 'fizz', 'buzz',
    'buzz', 'fizz', 'buzz', 'buzz', 'fizz',
    'buzz', 'buzz', 'fizz', 'buzz', 'buzz'
]
</code>
</pre>
<pre>
<code>
let email = "example@gmail.com";
console.log(email.split('@')[0]);
            
//output
example
</code>
</pre>

<pre>         
  <code>
  function shuffleArr(arr) {
          for (let i = arr.length - 1; i &gt; 0; i--) {
              let j = Math.floor(Math.random() * (i + 1)); // Random index from 0 to i
              [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap elements
          }
          return arr;
      }                                   
  </code>        
  <code>
      //other method
      function shuffleArr(arr) {
          return arr.sort(() =&gt; Math.random() - 0.5);
      }
      // Example usage
      let nums = [1, 2, 3, 4, 5, 6, 7];
      console.log(shuffleArr(nums));
  </code>
</pre>

<pre>                    
  <code>
//count vowels in a string
function app(str) {
    let vowels = 'aeiouAEIOU';
    let count= 0;
    
    for(let char of str){
        if(vowels.includes(char)){
            count++;
        }
    }
    return count;
}
console.log(app('abcdefghi'));
//output
3
                        
</code>
</pre>
<pre>
<code>
let nums = [9,1,2,3,4,5];
function isSorted(arr){
    for(let i=0; i < arr.length-1; i++){
        if(arr[i]>arr[i+1]){
            return 'false'
        }
    }
    return 'true'
}
console.log(isSorted(nums));   
</code>
</pre>
<pre>
  <code>
//find common value between two arr of intersaction value
                 
function arrayIntersection(arr1, arr2) {
    return arr1.filter(value => arr2.includes(value));
}
// Example usage:
console.log(arrayIntersection([1, 2, 3, 4, 5], [3, 4, 5, 6, 7])); // [3, 4, 5]
//another way
const nums1 = [1,2,3,4,5];
const nums2  = [1,2,3,6,7,8,9];
  </code>
</pre>

<pre>
  <code>
let person = {
              name: 'Vivek',
              age: 25.4554,
              role: 'UI'
            }          
console.log(Object.keys(person));
console.log(Object.values(person));
console.log(Object.entries(person));                  
console.log('email' in person);  
delete person.age;
console.log(person);

//Output

=> [ 'name', 'age', 'role' ]
=> [ 'Vivek', 25.4554, 'UI' ]
=> [ [ 'name', 'Vivek' ], [ 'age', 25.4554 ], [ 'role', 'UI' ] ]
=> false
=> { name: 'Vivek', role: 'UI' }
  </code>
</pre>

<pre>
  <code>
let colors = { 
                  red: "#FF0000", 
                  blue: "#0000FF", 
                  green: "#00FF00" 
                };
function myFun(val){
    return Object.keys(colors).find((key,ind)=>{
        return colors[key] === val
    })
} 
console.log(myFun('#FF0000'));
//Output
=>red
  </code>
</pre>

<pre>
  <code>
    let users = [
      { name: "Alice", age: 30 },
      { name: "dBob", age: 25 },
      { name: "Charlie", age: 35 }
    ];

const sortObj = users.sort((a, b) => a.name.localeCompare(b.name));
console.log('sorted object is...', sortObj);
  </code>
</pre>

<pre>
  <code>
    üîπ Basic Git & GitHub Questions
What is the difference between Git and GitHub?

Git is a distributed version control system.

GitHub is a hosting service for Git repositories with collaboration features.

What is the difference between git pull and git fetch?

git fetch: gets changes from the remote but does not merge.

git pull: fetches + merges into your current branch.

How do you revert a commit that has already been pushed to GitHub?

Use git revert <commit-hash> to create a new commit that undoes the changes.

What is a merge conflict, and how do you resolve it?

Occurs when changes in two branches conflict.

Resolve manually in the conflicting files, then add, commit.

What does git stash do?

Temporarily saves changes that are not ready to commit, allowing you to work on something else.

üîπ Intermediate Questions
Explain branching in Git. How do you create and switch branches?

git branch branch-name creates a branch.

git checkout branch-name switches to it (or use git switch in newer versions).

What is the difference between git merge and git rebase?

merge: joins two branches with a merge commit.

rebase: moves or combines commits to create a linear history.

What are tags in Git, and how do you use them in GitHub releases?

Tags mark specific points (e.g., versions). Use git tag v1.0.0 and git push origin --tags.

What are GitHub Actions? Have you used them?

CI/CD workflows triggered by events in your repo. You can automate tests, deployments, etc.

How do you protect a branch in GitHub?

Use Branch protection rules in GitHub settings to enforce status checks, reviews, etc.

üîπ Advanced GitHub Collaboration Questions
How do you handle Pull Request reviews in your workflow?

Steps: Create a PR ‚Üí Assign reviewers ‚Üí Address comments ‚Üí Merge after approvals/checks.

What is a Fork in GitHub, and how is it different from a branch?

A fork is a personal copy of someone else‚Äôs repo, used for contributing via pull requests.

Describe your GitHub workflow (e.g., Git Flow, trunk-based, etc.)

Could be:

Git Flow (feature, dev, release, hotfix)

GitHub Flow (main + feature branches + PRs)

Trunk-based (short-lived branches, continuous deployment)

How do you handle large binary files in GitHub?

Use Git LFS (Large File Storage) to track binaries without bloating the repo.

What tools or integrations have you used with GitHub?

GitHub Actions, Jenkins, Netlify, Vercel, Codecov, Dependabot, Slack notifications, etc.

Bonus: Questions for UI/UX or Frontend Roles
How do you collaborate with designers or product managers using GitHub?

Feature branches, tagging, PR descriptions with screenshots or design links.

How do you manage frontend assets and versioning in GitHub?

Semantic versioning via tags, changelogs, bundling tools, and GitHub releases.

Have you ever used GitHub Projects or Issues for project management?

Describe use cases like Kanban boards, issue tracking, milestones, etc.
  </code>
</pre>

</div>

</div>



  
    
  
</body>
</html>